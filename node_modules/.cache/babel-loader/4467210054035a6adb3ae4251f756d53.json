{"ast":null,"code":"import { WORDS } from '../constants/wordlist';\nimport { VALID_GUESSES } from '../constants/validGuesses';\nimport { WRONG_SPOT_MESSAGE, NOT_CONTAINED_MESSAGE } from '../constants/strings';\nimport { getGuessStatuses } from './statuses';\nimport { default as GraphemeSplitter } from 'grapheme-splitter';\nexport const isWordInWordList = word => {\n  return WORDS.includes(localeAwareLowerCase(word)) || VALID_GUESSES.includes(localeAwareLowerCase(word));\n};\nexport const isWinningWord = word => {\n  return solution === word;\n}; // build a set of previously revealed letters - present and correct\n// guess must use correct letters in that space and any other revealed letters\n// also check if all revealed instances of a letter are used (i.e. two C's)\n\nexport const findFirstUnusedReveal = (word, guesses) => {\n  if (guesses.length === 0) {\n    return false;\n  }\n\n  const lettersLeftArray = new Array();\n  const guess = guesses[guesses.length - 1];\n  const statuses = getGuessStatuses(solution, guess);\n  const splitWord = unicodeSplit(word);\n  const splitGuess = unicodeSplit(guess);\n\n  for (let i = 0; i < splitGuess.length; i++) {\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\n      lettersLeftArray.push(splitGuess[i]);\n    }\n\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1);\n    }\n  } // check for the first unused letter, taking duplicate letters\n  // into account - see issue #198\n\n\n  let n;\n\n  for (const letter of splitWord) {\n    n = lettersLeftArray.indexOf(letter);\n\n    if (n !== -1) {\n      lettersLeftArray.splice(n, 1);\n    }\n  }\n\n  if (lettersLeftArray.length > 0) {\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0]);\n  }\n\n  return false;\n};\nexport const unicodeSplit = word => {\n  return new GraphemeSplitter().splitGraphemes(word);\n};\nexport const unicodeLength = word => {\n  return unicodeSplit(word).length;\n};\nexport const localeAwareLowerCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING) : text.toLowerCase();\n};\nexport const localeAwareUpperCase = text => {\n  return process.env.REACT_APP_LOCALE_STRING ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING) : text.toUpperCase();\n};\nexport const getWordOfDay = () => {\n  // January 1, 2022 Game Epoch\n  // const epoch = new Date(2022, 0)\n  // const start = new Date(epoch)\n  // const today = new Date()\n  // today.setHours(0, 0, 0, 0)\n  let index = 0;\n\n  while (0 < 1) {\n    index++; // start.setDate(start.getDate() + 1)\n  }\n\n  const nextDay = new Date();\n  var seconds = nextDay.getMilliseconds; // nextDay.setDate(today.getDate() + 1)\n\n  return {\n    solution: localeAwareUpperCase(WORDS[index % WORDS.length]),\n    solutionIndex: index,\n    tomorrow: seconds.valueOf()\n  };\n};\nexport const {\n  solution,\n  solutionIndex,\n  tomorrow\n} = getWordOfDay();","map":{"version":3,"sources":["C:/Users/DELL/OneDrive/wordle-mongol/src/lib/words.ts"],"names":["WORDS","VALID_GUESSES","WRONG_SPOT_MESSAGE","NOT_CONTAINED_MESSAGE","getGuessStatuses","default","GraphemeSplitter","isWordInWordList","word","includes","localeAwareLowerCase","isWinningWord","solution","findFirstUnusedReveal","guesses","length","lettersLeftArray","Array","guess","statuses","splitWord","unicodeSplit","splitGuess","i","push","n","letter","indexOf","splice","splitGraphemes","unicodeLength","text","process","env","REACT_APP_LOCALE_STRING","toLocaleLowerCase","toLowerCase","localeAwareUpperCase","toLocaleUpperCase","toUpperCase","getWordOfDay","index","nextDay","Date","seconds","getMilliseconds","solutionIndex","tomorrow","valueOf"],"mappings":"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","sourcesContent":["import { WORDS } from '../constants/wordlist'\r\nimport { VALID_GUESSES } from '../constants/validGuesses'\r\nimport { WRONG_SPOT_MESSAGE, NOT_CONTAINED_MESSAGE } from '../constants/strings'\r\nimport { getGuessStatuses } from './statuses'\r\nimport { default as GraphemeSplitter } from 'grapheme-splitter'\r\n\r\nexport const isWordInWordList = (word: string) => {\r\n  return (\r\n    WORDS.includes(localeAwareLowerCase(word)) ||\r\n    VALID_GUESSES.includes(localeAwareLowerCase(word))\r\n  )\r\n}\r\n\r\nexport const isWinningWord = (word: string) => {\r\n  return solution === word\r\n}\r\n\r\n// build a set of previously revealed letters - present and correct\r\n// guess must use correct letters in that space and any other revealed letters\r\n// also check if all revealed instances of a letter are used (i.e. two C's)\r\nexport const findFirstUnusedReveal = (word: string, guesses: string[]) => {\r\n  if (guesses.length === 0) {\r\n    return false\r\n  }\r\n\r\n  const lettersLeftArray = new Array<string>()\r\n  const guess = guesses[guesses.length - 1]\r\n  const statuses = getGuessStatuses(solution, guess)\r\n  const splitWord = unicodeSplit(word)\r\n  const splitGuess = unicodeSplit(guess)\r\n\r\n  for (let i = 0; i < splitGuess.length; i++) {\r\n    if (statuses[i] === 'correct' || statuses[i] === 'present') {\r\n      lettersLeftArray.push(splitGuess[i])\r\n    }\r\n    if (statuses[i] === 'correct' && splitWord[i] !== splitGuess[i]) {\r\n      return WRONG_SPOT_MESSAGE(splitGuess[i], i + 1)\r\n    }\r\n  }\r\n\r\n  // check for the first unused letter, taking duplicate letters\r\n  // into account - see issue #198\r\n  let n\r\n  for (const letter of splitWord) {\r\n    n = lettersLeftArray.indexOf(letter)\r\n    if (n !== -1) {\r\n      lettersLeftArray.splice(n, 1)\r\n    }\r\n  }\r\n\r\n  if (lettersLeftArray.length > 0) {\r\n    return NOT_CONTAINED_MESSAGE(lettersLeftArray[0])\r\n  }\r\n  return false\r\n}\r\n\r\nexport const unicodeSplit = (word: string) => {\r\n  return new GraphemeSplitter().splitGraphemes(word)\r\n}\r\n\r\nexport const unicodeLength = (word: string) => {\r\n  return unicodeSplit(word).length\r\n}\r\n\r\nexport const localeAwareLowerCase = (text: string) => {\r\n  return process.env.REACT_APP_LOCALE_STRING\r\n    ? text.toLocaleLowerCase(process.env.REACT_APP_LOCALE_STRING)\r\n    : text.toLowerCase()\r\n}\r\n\r\nexport const localeAwareUpperCase = (text: string) => {\r\n  return process.env.REACT_APP_LOCALE_STRING\r\n    ? text.toLocaleUpperCase(process.env.REACT_APP_LOCALE_STRING)\r\n    : text.toUpperCase()\r\n}\r\n\r\n\r\nexport const getWordOfDay = () => {\r\n  // January 1, 2022 Game Epoch\r\n  // const epoch = new Date(2022, 0)\r\n  // const start = new Date(epoch)\r\n  // const today = new Date()\r\n  // today.setHours(0, 0, 0, 0)\r\n  let index = 0\r\n  while (0 < 1) {\r\n    index++\r\n    // start.setDate(start.getDate() + 1)\r\n  }\r\n\r\n  const nextDay = new Date()\r\n  var seconds = nextDay.getMilliseconds \r\n\r\n  // nextDay.setDate(today.getDate() + 1)\r\n\r\n  return {\r\n    solution: localeAwareUpperCase(WORDS[index % WORDS.length]),\r\n    solutionIndex: index,\r\n    tomorrow: seconds.valueOf(),\r\n  }\r\n}\r\n\r\nexport const { solution, solutionIndex, tomorrow } = getWordOfDay()\r\n"]},"metadata":{},"sourceType":"module"}