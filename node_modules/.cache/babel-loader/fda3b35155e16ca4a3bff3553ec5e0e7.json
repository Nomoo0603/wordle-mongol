{"ast":null,"code":"import { unicodeSplit } from './words';\nexport const getStatuses = (solution, guesses) => {\n  const charObj = {};\n  const splitSolution = unicodeSplit(solution);\n  guesses.forEach(word => {\n    unicodeSplit(word).forEach((letter, i) => {\n      if (!splitSolution.includes(letter)) {\n        // make status absent\n        return charObj[letter] = 'absent';\n      }\n\n      if (letter === splitSolution[i]) {\n        //make status correct\n        return charObj[letter] = 'correct';\n      }\n\n      if (charObj[letter] !== 'correct') {\n        //make status present\n        return charObj[letter] = 'present';\n      }\n    });\n  });\n  return charObj;\n};\nexport const getGuessStatuses = (solution, guess) => {\n  const splitSolution = unicodeSplit(solution);\n  const splitGuess = unicodeSplit(guess);\n  const solutionCharsTaken = splitSolution.map(_ => false);\n  const statuses = Array.from(Array(guess.length)); // handle all correct cases first\n\n  splitGuess.forEach((letter, i) => {\n    if (letter === splitSolution[i]) {\n      statuses[i] = 'correct';\n      solutionCharsTaken[i] = true;\n      return;\n    }\n  });\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return;\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent';\n      return;\n    } // now we are left with \"present\"s\n\n\n    const indexOfPresentChar = splitSolution.findIndex((x, index) => x === letter && !solutionCharsTaken[index]);\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'present';\n      solutionCharsTaken[indexOfPresentChar] = true;\n      return;\n    } else {\n      statuses[i] = 'absent';\n      return;\n    }\n  });\n  return statuses;\n};","map":{"version":3,"sources":["C:/Users/DELL/OneDrive/wordle-mongol/src/lib/statuses.ts"],"names":["unicodeSplit","getStatuses","solution","guesses","charObj","splitSolution","forEach","word","letter","i","includes","getGuessStatuses","guess","splitGuess","solutionCharsTaken","map","_","statuses","Array","from","length","indexOfPresentChar","findIndex","x","index"],"mappings":"AAAA,SAASA,YAAT,QAA6B,SAA7B;AAIA,OAAO,MAAMC,WAAW,GAAG,CACzBC,QADyB,EAEzBC,OAFyB,KAGS;AAClC,QAAMC,OAAsC,GAAG,EAA/C;AACA,QAAMC,aAAa,GAAGL,YAAY,CAACE,QAAD,CAAlC;AAEAC,EAAAA,OAAO,CAACG,OAAR,CAAiBC,IAAD,IAAU;AACxBP,IAAAA,YAAY,CAACO,IAAD,CAAZ,CAAmBD,OAAnB,CAA2B,CAACE,MAAD,EAASC,CAAT,KAAe;AACxC,UAAI,CAACJ,aAAa,CAACK,QAAd,CAAuBF,MAAvB,CAAL,EAAqC;AACnC;AACA,eAAQJ,OAAO,CAACI,MAAD,CAAP,GAAkB,QAA1B;AACD;;AAED,UAAIA,MAAM,KAAKH,aAAa,CAACI,CAAD,CAA5B,EAAiC;AAC/B;AACA,eAAQL,OAAO,CAACI,MAAD,CAAP,GAAkB,SAA1B;AACD;;AAED,UAAIJ,OAAO,CAACI,MAAD,CAAP,KAAoB,SAAxB,EAAmC;AACjC;AACA,eAAQJ,OAAO,CAACI,MAAD,CAAP,GAAkB,SAA1B;AACD;AACF,KAfD;AAgBD,GAjBD;AAmBA,SAAOJ,OAAP;AACD,CA3BM;AA6BP,OAAO,MAAMO,gBAAgB,GAAG,CAC9BT,QAD8B,EAE9BU,KAF8B,KAGb;AACjB,QAAMP,aAAa,GAAGL,YAAY,CAACE,QAAD,CAAlC;AACA,QAAMW,UAAU,GAAGb,YAAY,CAACY,KAAD,CAA/B;AAEA,QAAME,kBAAkB,GAAGT,aAAa,CAACU,GAAd,CAAmBC,CAAD,IAAO,KAAzB,CAA3B;AAEA,QAAMC,QAAsB,GAAGC,KAAK,CAACC,IAAN,CAAWD,KAAK,CAACN,KAAK,CAACQ,MAAP,CAAhB,CAA/B,CANiB,CAQjB;;AACAP,EAAAA,UAAU,CAACP,OAAX,CAAmB,CAACE,MAAD,EAASC,CAAT,KAAe;AAChC,QAAID,MAAM,KAAKH,aAAa,CAACI,CAAD,CAA5B,EAAiC;AAC/BQ,MAAAA,QAAQ,CAACR,CAAD,CAAR,GAAc,SAAd;AACAK,MAAAA,kBAAkB,CAACL,CAAD,CAAlB,GAAwB,IAAxB;AACA;AACD;AACF,GAND;AAQAI,EAAAA,UAAU,CAACP,OAAX,CAAmB,CAACE,MAAD,EAASC,CAAT,KAAe;AAChC,QAAIQ,QAAQ,CAACR,CAAD,CAAZ,EAAiB;;AAEjB,QAAI,CAACJ,aAAa,CAACK,QAAd,CAAuBF,MAAvB,CAAL,EAAqC;AACnC;AACAS,MAAAA,QAAQ,CAACR,CAAD,CAAR,GAAc,QAAd;AACA;AACD,KAP+B,CAShC;;;AACA,UAAMY,kBAAkB,GAAGhB,aAAa,CAACiB,SAAd,CACzB,CAACC,CAAD,EAAIC,KAAJ,KAAcD,CAAC,KAAKf,MAAN,IAAgB,CAACM,kBAAkB,CAACU,KAAD,CADxB,CAA3B;;AAIA,QAAIH,kBAAkB,GAAG,CAAC,CAA1B,EAA6B;AAC3BJ,MAAAA,QAAQ,CAACR,CAAD,CAAR,GAAc,SAAd;AACAK,MAAAA,kBAAkB,CAACO,kBAAD,CAAlB,GAAyC,IAAzC;AACA;AACD,KAJD,MAIO;AACLJ,MAAAA,QAAQ,CAACR,CAAD,CAAR,GAAc,QAAd;AACA;AACD;AACF,GAtBD;AAwBA,SAAOQ,QAAP;AACD,CA7CM","sourcesContent":["import { unicodeSplit } from './words'\r\n\r\nexport type CharStatus = 'absent' | 'present' | 'correct'\r\n\r\nexport const getStatuses = (\r\n  solution: string,\r\n  guesses: string[]\r\n): { [key: string]: CharStatus } => {\r\n  const charObj: { [key: string]: CharStatus } = {}\r\n  const splitSolution = unicodeSplit(solution)\r\n\r\n  guesses.forEach((word) => {\r\n    unicodeSplit(word).forEach((letter, i) => {\r\n      if (!splitSolution.includes(letter)) {\r\n        // make status absent\r\n        return (charObj[letter] = 'absent')\r\n      }\r\n\r\n      if (letter === splitSolution[i]) {\r\n        //make status correct\r\n        return (charObj[letter] = 'correct')\r\n      }\r\n\r\n      if (charObj[letter] !== 'correct') {\r\n        //make status present\r\n        return (charObj[letter] = 'present')\r\n      }\r\n    })\r\n  })\r\n\r\n  return charObj\r\n}\r\n\r\nexport const getGuessStatuses = (\r\n  solution: string,\r\n  guess: string\r\n): CharStatus[] => {\r\n  const splitSolution = unicodeSplit(solution)\r\n  const splitGuess = unicodeSplit(guess)\r\n\r\n  const solutionCharsTaken = splitSolution.map((_) => false)\r\n\r\n  const statuses: CharStatus[] = Array.from(Array(guess.length))\r\n\r\n  // handle all correct cases first\r\n  splitGuess.forEach((letter, i) => {\r\n    if (letter === splitSolution[i]) {\r\n      statuses[i] = 'correct'\r\n      solutionCharsTaken[i] = true\r\n      return\r\n    }\r\n  })\r\n\r\n  splitGuess.forEach((letter, i) => {\r\n    if (statuses[i]) return\r\n\r\n    if (!splitSolution.includes(letter)) {\r\n      // handles the absent case\r\n      statuses[i] = 'absent'\r\n      return\r\n    }\r\n\r\n    // now we are left with \"present\"s\r\n    const indexOfPresentChar = splitSolution.findIndex(\r\n      (x, index) => x === letter && !solutionCharsTaken[index]\r\n    )\r\n\r\n    if (indexOfPresentChar > -1) {\r\n      statuses[i] = 'present'\r\n      solutionCharsTaken[indexOfPresentChar] = true\r\n      return\r\n    } else {\r\n      statuses[i] = 'absent'\r\n      return\r\n    }\r\n  })\r\n\r\n  return statuses\r\n}\r\n"]},"metadata":{},"sourceType":"module"}